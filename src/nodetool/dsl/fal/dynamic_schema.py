# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import (
    OutputHandle,
    OutputsProxy,
    DynamicOutputsProxy,
    connect_field,
)
import nodetool.nodes.fal.dynamic_schema
from nodetool.workflows.base_node import BaseNode


class DynamicFalSchema(GraphNode[dict[str, Any]]):
    """

        Dynamic FAL schema-driven node for running any fal.ai endpoint.
        fal, schema, dynamic, openapi, inference, runtime, model

        Use cases:
        - Call new fal.ai endpoints without adding new Python nodes
        - Prototype workflows with experimental FAL models
        - Run custom endpoints by pasting their OpenAPI schema
        - Build flexible pipelines that depend on runtime model selection
        - Explore model inputs/outputs directly from OpenAPI metadata

    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = DynamicFalSchema(prop1=value1, prop2=value2)
    """

    model_url: str | OutputHandle[str] = connect_field(
        default="",
        description="fal.ai model URL (e.g. https://fal.ai/models/fal-ai/flux/dev)",
    )
    endpoint_id: str | OutputHandle[str] = connect_field(
        default="", description="FAL endpoint id (e.g. fal-ai/flux/dev)"
    )
    schema_url: str | OutputHandle[str] = connect_field(
        default="", description="URL to the OpenAPI schema JSON for the endpoint"
    )
    openapi_json: (
        dict[str, typing.Any] | str | OutputHandle[dict[str, typing.Any] | str] | None
    ) = connect_field(
        default=None, description="Raw OpenAPI schema JSON (string or object)"
    )
    inputs: dict[str, typing.Any] | OutputHandle[dict[str, typing.Any]] | None = (
        connect_field(
            default=None,
            description="Optional input values for the endpoint (overrides dynamic properties)",
        )
    )

    def __init__(
        self,
        *,
        dynamic_outputs: dict[str, typing.Any] | None = None,
        **kwargs: typing.Any,
    ) -> None:
        """
        Initialize a DynamicFalSchema node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Dynamic outputs declared here will be forwarded to the underlying node
        so they are available when the workflow executes. Provide Python types
        such as str or list[int] for each output.

        Args:
            dynamic_outputs: Optional mapping from output names to Python types.
            **kwargs: Field values and dynamic properties.
        """

        outputs = {} if dynamic_outputs is None else dict(dynamic_outputs)
        super().__init__(dynamic_outputs=outputs, **kwargs)

    @property
    def out(self) -> DynamicOutputsProxy:
        return typing.cast(DynamicOutputsProxy, self._outputs_proxy())

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.fal.dynamic_schema.DynamicFalSchema

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
