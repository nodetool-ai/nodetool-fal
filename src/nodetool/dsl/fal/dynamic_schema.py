# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, DynamicOutputsProxy, connect_field
import nodetool.nodes.fal.dynamic_schema
from nodetool.workflows.base_node import BaseNode

class FalAI(GraphNode[dict[str, Any]]):
    """

        Dynamic FAL node for running any fal.ai endpoint.
        fal, schema, dynamic, openapi, inference, runtime, model

        Use cases:
        - Call new fal.ai endpoints without adding new Python nodes
        - Prototype workflows with experimental FAL models
        - Run custom endpoints by sharing model info (llms.txt)
        - Build flexible pipelines that depend on runtime model selection

    This node supports dynamic properties. Additional properties can be passed
    as keyword arguments during initialization and will be stored in the node's
    dynamic_properties dictionary.

    Example:
        node = FalAI(prop1=value1, prop2=value2)
    """

    model_info: str | OutputHandle[str] = connect_field(default='', description='Paste the full llms.txt from the fal.ai model page (e.g. fal.ai/models/... â†’ copy all).')

    def __init__(self, *, dynamic_outputs: dict[str, typing.Any] | None = None, **kwargs: typing.Any) -> None:
        """
        Initialize a FalAI node.

        Extra keyword arguments beyond the defined fields will be treated as
        dynamic properties and automatically passed to the underlying BaseNode
        as dynamic_properties.

        Dynamic outputs declared here will be forwarded to the underlying node
        so they are available when the workflow executes. Provide Python types
        such as str or list[int] for each output.

        Args:
            dynamic_outputs: Optional mapping from output names to Python types.
            **kwargs: Field values and dynamic properties.
        """

        outputs = {} if dynamic_outputs is None else dict(dynamic_outputs)
        super().__init__(dynamic_outputs=outputs, **kwargs)

    @property
    def out(self) -> DynamicOutputsProxy:
        return typing.cast(DynamicOutputsProxy, self._outputs_proxy())

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.fal.dynamic_schema.FalAI

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


